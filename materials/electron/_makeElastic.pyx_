#profiler = True


##############################################################################
#########################        DEBUG         ###############################


cdef void LOG( msg):
    with open("makeElastic.txt", mode = 'a') as f:
        f.write(msg + "\n")


LOG("\n")


LOG("OPENED MODULE")
##############################################################################
##############################################################################












from libc.math cimport pi, log, floor
cimport cython
from scipy.interpolate import CubicSpline
from MontyCarlo.tools cimport search
from numpy import zeros, array
from MontyCarlo.tools.interpol1 cimport LinLinInterpolation
from MontyCarlo.tools cimport CubicInverseTransform


from numpy cimport ndarray

from ...settings import __montecarlo__


__path__ = __montecarlo__/'materials'/'electron'


__path__ = str(__path__)


from libc.stdlib cimport rand, RAND_MAX




cimport cython
@cython.cdivision(True)
cdef double urand():
    cdef double r = rand()
    return r / RAND_MAX



# cdef double RAND_MAX2 = RAND_MAX + 1
# @cython.cdivision(True)
# cdef double urand():
#     cdef double r = rand()
#     return (r+1) / RAND_MAX2
#from numpy.random import rand as urand

#import numpy as np

        


@cython.boundscheck(True)
@cython.wraparound(False) 
@cython.initializedcheck(False)
@cython.cdivision(True)
cdef class FastCubicSpline:

    
    def __init__(self, double[:] x, double[:] y):
        cdef object spline = CubicSpline(x, y)
        self.x = spline.x
        self.c = spline.c
        self.N = len(x) - 1
        
    cdef double _eval(self, double x):
        cdef int i = search._sortedArrayDOUBLE(self.x, x, 0, self.N) - 1
        
        if i == -1: 
            i = 0

        cdef double y = 0
        cdef double xi = self.x[i]
        cdef int k
        for k in range(0, 4):
            y += self.c[k, i]*(x - xi)**(3-k)
        return y
    
    def eval(self, double x):
        return self._eval(x)
    
    
    

@cython.boundscheck(True)
@cython.wraparound(False) 
@cython.initializedcheck(False)
@cython.cdivision(True)
cdef class sFastCubicSpline:

    def __init__(self, ndarray invcum, ndarray y):
        
        
        
        hashed = np.floor(invcum*len(invcum))
        indexes = np.arange(0, len(hashed))
         
        Imax = int(max(indexes))
         
        lims = []
        for i in range(Imax + 2):
            _indexes = indexes[hashed == i]
             
            n = len(_indexes)
             
            if n < 2:
                lims.append(np.array([0, 0, n], dtype = int))
                continue
             
            _lims = [_indexes[0], _indexes[n-1], n]
            lims.append(np.array(_lims, dtype = int))
            
        self.lims = np.array(lims)
        #print(np.array(self.lims))
        
        
        cdef object spline = CubicSpline(invcum, y)
        
        self.x = spline.x
        self.c = spline.c
        self.N = len(spline.c[0]) -1    
        
        
        
        
        
        
        
        
        
        
        # #cdef ndarray invcum = np.array(x)
        # #def ndarray invcum = x
        
        # sc = invcum*len(invcum)
        
        # cdef ndarray fl = np.floor(sc)
        # cdef int NN = len(fl)
        
        
        
        
        
        
        
        
        
        
        
        # cdef list lims = []
        # cdef int i, k, l
        # cdef int[:] kl
        # for i in range(len(invcum)):
            
        #     #k = search._sortedArrayDOUBLE(fl, i,     0, NN-1)
        #     #l = search._sortedArrayDOUBLE(fl, i + 1, 0, NN-1)
            
        #     k =  np.searchsorted(fl, i,     side = "right")
        #     l =  np.searchsorted(fl, i + 1, side = "right")

        
        #     kl = np.array([k-1, l, l - k + 1])
        #     lims.append(kl)
            

        # self.lims =  np.array(lims)        
        
        
        
        
        

        
        




    cdef double sample_rc(self, double rc):
        #LOG(f"sampler_rc(rc = {rc})")
        cdef double r = urand()
        self.r = rc + (1 - rc)*r
        
        self.fr = <Py_ssize_t> self.r*self.N

        
        if self.lims[self.fr, 2] < 3:
            self.fr = self.lims[self.fr, 0]


            self.y = self.c[3, self.fr]
            
            self.dx = self.r - self.x[self.fr]
            self.y += self.c[2, self.fr]*self.dx
            
            self.dx *= self.dx
            self.y += self.c[1, self.fr]*self.dx
            
            self.dx *= self.dx
            self.y += self.c[0, self.fr]*self.dx
            
            
            return self.y            
            
            
            
        

        self.fr = <Py_ssize_t> search._sortedArrayDOUBLE(self.x, 
                                            self.r, 
                                            self.lims[self.fr, 0], 
                                            self.lims[self.fr, 1] )
        

        

        
            
        self.y = self.c[3, self.fr]

        self.dx = self.r - self.x[self.fr]
        self.y += self.c[2, self.fr]*self.dx
        
        self.dx *= self.dx
        self.y += self.c[1, self.fr]*self.dx
        
        self.dx *= self.dx
        self.y += self.c[0, self.fr]*self.dx
        
        
        return self.y 

    cdef double _eval_rc(self, double rc):
        self.fr = <Py_ssize_t> rc*self.N

        

        
        if self.lims[self.fr, 2] < 3:
            self.fr = self.lims[self.fr, 0]
            
            
            self.y = self.c[3, self.fr]
            
            self.dx = self.r - self.x[self.fr]
            self.y += self.c[2, self.fr]*self.dx
            
            self.dx *= self.dx
            self.y += self.c[1, self.fr]*self.dx
            
            self.dx *= self.dx
            self.y += self.c[0, self.fr]*self.dx
            
            
            return self.y            
            
            
            
        

        
        self.fr = <Py_ssize_t> (search._sortedArrayDOUBLE(self.x, 
                                            self.r, 
                                            self.lims[self.fr, 0], 
                                            self.lims[self.fr, 1]))
        

        
        
        self.y = self.c[3, self.fr]
        
        self.dx = self.r - self.x[self.fr]
        self.y += self.c[2, self.fr]*self.dx
        
        self.dx *= self.dx
        self.y += self.c[1, self.fr]*self.dx
        
        self.dx *= self.dx
        self.y += self.c[0, self.fr]*self.dx
        
        
        return self.y 

    
        
        #return self._evalINDEX(self.fr, self.r)
        
        
    cdef double _eval(self, double x):
        cdef int i = search._sortedArrayDOUBLE(self.x, x, 0, self.N) - 1
        
        if i == -1: 
            i = 0

        cdef double y = 0
        #cdef double xi = 
        cdef int k
        for k in range(0, 4):
            y += self.c[k, i]*(x - self.x[i])**(3-k)
        return y
    
    cdef double _evalINDEX(self, Py_ssize_t i, double x):
        self.y = 0
        
        cdef Py_ssize_t k
        for k in range(0, 4):
            self.y += self.c[k, i]*(x - self.x[i])**(3-k)
        return self.y        
    
    cdef double sample(self):
        self.r = urand()
        self.fr = <Py_ssize_t> floor(self.r*self.N) - 1
        
        cdef double dx
        if self.lims[self.fr, 2] < 1:
            self.fr = self.lims[self.fr, 0]
            
            self.y = self.c[3, self.fr]

            
            dx = self.r - self.x[self.fr]
            self.y += self.c[0, self.fr]*(dx)**3
            self.y += self.c[1, self.fr]*(dx)**2
            self.y += self.c[2, self.fr]*(dx)
            return self.y            
            
            
            #return self._evalINDEX(self.lims[self.fr, 0], self.r)
        

        
        self.fr = <Py_ssize_t> (search._sortedArrayDOUBLE(self.x, 
                                            self.r, 
                                            self.lims[self.fr, 0], 
                                            self.lims[self.fr, 1]) - 1)
        
        
        
        self.y = self.c[3, self.fr]
        
        dx = self.r - self.x[self.fr]
        
        self.y += self.c[0, self.fr]*(dx)**3
        self.y += self.c[1, self.fr]*(dx)**2
        self.y += self.c[2, self.fr]*(dx)
        return self.y    
    
    
    def eval(self, double x):
        return self._eval(x)
    
    def pysample2(self, int N = 100):
        cdef int i
        cdef double[:] s = np.zeros(N)
        for i in range(N):
            s[i] = self.sample()   
        return s    
    
    
    def pysample(self, int N = 100):
        cdef int i
        
        for i in range(N):
            self.sample()  
    
    
    
    
    
    
def getData(Z):
    import pickle
    path = __path__ + f"/{Z}/{Z}.pkl"
    with open(path, 'rb') as pkl_file:
        data = pickle.load(pkl_file)
    return data
    
    
    
def _getData(Z):
    from numpy import array, zeros
    from os import listdir
    path = __path__ + f"/{Z}/"
    files = listdir(path)
    print(path)

    
    eax = []
    
    for file in files:
        e = file[4:12].replace("p", ".")
        e = float(e)
        eax.append(e)
    
    n = len(eax)
    print(n)
    
    files = [f for _, f in sorted(zip(eax, files))]
    
    allDCS = zeros((n, 606))
    SIGMA0 = zeros(n)
    SIGMA1 = zeros(n)
    SIGMA2 = zeros(n)
    
    for j, file in enumerate(files):

        with open(path + file, "r") as f:
            lines = f.readlines()
        
        DCS = zeros(606)

        for line in lines:
            if line[1] == "#":
                if "Total elastic cross section" in line:
                    SIGMA0[j] =  float(line.split()[6]) 
                if "1st transport cross section" in line:
                    SIGMA1[j] = float(line.split()[6])
                if "2nd transport cross section" in line:
                    SIGMA2[j] = float(line.split()[6]) 
                    i = 0
                    continue
 
                continue
            numb = line.split()
            dcs = numb[2]
            DCS[i] = float(dcs)
            i += 1

        allDCS[j] = DCS*4*pi
    eax.sort()
    return allDCS, SIGMA0, SIGMA1, SIGMA2, array(eax)

import numpy as np
cdef object remove_duplicates(ndarray x, ndarray Y):
    cdef ndarray u, c, dup
    u, c = np.unique(x, return_counts=True)
    dup = u[c > 1]
    
    cdef bint keep = True
    cdef list new_y = []
    cdef int i
    cdef double y
    
    for i, y in enumerate(Y):
        
        if x[i] in dup:
            if keep:
                new_y.append(y)
                keep = False
                continue
            else: continue
        
        if keep is False:
            keep = True
        new_y.append(y)
    
    return u, np.array(new_y)

def pygetCIT(X, Y):
    return getCIT(X, Y)



from scipy.integrate import quad, trapz, cumtrapz
cdef sFastCubicSpline getCIT(ndarray X, ndarray Y):
    
    

    cdef double I = trapz(Y, X)
    Y = Y/I
        

    
    cdef ndarray cumul
    
    cumul = cumtrapz(Y, X, initial = 0)
    cumul, X = remove_duplicates(cumul, X)
    

    #import numpy as np
    #cumul = np.array(cumul)
    
    #dx = np.diff(cumul)
    #if np.any(dx <= 0):
    #    print(cumul)
    #    raise ValueError("`x` must be strictly increasing sequence.")

    return sFastCubicSpline( cumul, X)

        
        
        
def compose(object formula):
    
    cdef ndarray allDCS, SIGMA0, SIGMA1, SIGMA2
    
    allDCS = zeros((200, 606))
    SIGMA0 = zeros(200)
    SIGMA1 = zeros(200)
    SIGMA2 = zeros(200)
    
    cdef int Z
    cdef double x
    
    for Z, x in formula.items():
        dcs, sigma0, sigma1, sigma2, eax = getData(Z)
        
        SIGMA0 += x*sigma0
        SIGMA1 += x*sigma1
        SIGMA2 += x*sigma2
        
        allDCS += x*dcs
        
    return eax, allDCS, SIGMA0, SIGMA1, SIGMA2




def getTs(mu, DCS):
    
    sigma0 = trapz(DCS, mu)
    
    p = DCS/sigma0
    
    T1 = mu*p
    T2 = mu**2 * p
    
    T1 = cumtrapz(T1, mu, initial = 0)
    T2 = cumtrapz(T2, mu, initial = 0)
    return T1, T2
    
    
    
    
  
        
        



from numpy cimport ndarray

@cython.boundscheck(True)
@cython.wraparound(False) 
@cython.initializedcheck(False)
@cython.cdivision(True)
cdef class sampler:
#mu, eax, allDCS, SIGMA0
    def __init__(self, 
                 ndarray mu, 
                 ndarray eax, 
                 ndarray allDCS, 
                 ndarray SIGMA0):
                 
                 
                 #mu, eax, allDCS, SIGMA0, SIGMA1, SIGMA2, grid = None):
                     
        print("            sampler.__init__")
        from numpy import log
        self.E = eax
        self.logE = log(eax)
        self.En = len(eax) - 1
        
        
        cdef list samplers = []
        cdef list T1 = []
        cdef list T2 = []
        cdef int i
        
        print("            > getting CITA's")
        for i in range(self.En + 1):
            
            samplers.append(
                 getCIT(mu, allDCS[i])
                )
            
            t1, t2 = getTs(mu, allDCS[i])
            
            T1.append(LinLinInterpolation(mu, t1))
            T2.append(LinLinInterpolation(mu, t2))
            
            
        
        
        print("            > final var")
        self.samplers = np.array(samplers)
        self.T1 = np.array(T1)
        self.T2 = np.array(T2)
        
        print("            > exiting init")
        
        #self.SIGMA0 = LinLinInterpolation(eax, SIGMA0)
        #self.SIGMA1 = LinLinInterpolation(eax, SIGMA1)
        #self.SIGMA2 = LinLinInterpolation(eax, SIGMA2)
        
        

        
    cdef double sample(self, double E, double rc):
        
        cdef int i = search._sortedArrayDOUBLE(self.E, E, 0, self.En)
        

        cdef sFastCubicSpline sam
        
        if i == -1 or i == 0:
            sam = self.samplers[0]
            return sam.sample_rc(rc)
        
        
        if self.E[i] == E:
            sam = self.samplers[i]
            return sam.sample_rc(rc)
        
        
        
        #logE1, logE2 = self.logE[i-1], 

        #cdef double log_diff = logE2 - logE1
        
        #cdef double pi_1 = 
        #pi_1 = ( logE2 - logE ) / log_diff
        
 
        #pi_2 = (logE - logE1)/log_diff
        
        

        
        if urand() < ( self.logE[i] - log(E) ) / (self.logE[i] - self.logE[i-1]):
            sam = self.samplers[i-1]
            return sam.sample_rc(rc)
        sam = self.samplers[i]
        return sam.sample_rc(rc)
    
    
    cpdef (double, double) T(self, double E, double rc):
        
        cdef int i = search._sortedArrayDOUBLE(self.E, E, 0, self.En)
        cdef double mu_c
        cdef sFastCubicSpline sam
        cdef LinLinInterpolation T1, T2
 
        
        if i == -1 or i == 0:
            sam = self.samplers[0]
            mu_c = sam._eval_rc(rc)
            T1 = self.T1[0]
            T2 = self.T2[0]
            return T1._eval(mu_c), T2._eval(mu_c)
        
        
        if self.E[i] == E:
            sam = self.samplers[i]
            mu_c = sam._eval_rc(rc) 
            
            T1 = self.T1[i]
            T2 = self.T2[i]
            
            return T1._eval(mu_c), T2._eval(mu_c)


        if urand() < ( self.logE[i] - log(E) ) / (self.logE[i] - self.logE[i-1]):
            T1 = self.T1[i-1]
            T2 = self.T2[i-1]
            
            sam = self.samplers[i-1]
            mu_c = sam._eval_rc(rc)
            return T1._eval(mu_c), T2._eval(mu_c)
        
        sam  = self.samplers[i]
        mu_c = sam._eval_rc(rc)
        T1 = self.T1[i]
        T2 = self.T2[i]
        return T1._eval(mu_c), T2._eval(mu_c)
    
    def pysample(self, double E, int N = 100):
        cdef int i
        
        for i in range(N):
            self.sample(E, 0)
            
    def pysample2(self, double E, double rc, int N = 100):
        cdef int i
        cdef double[:] s = np.zeros(N)
        for i in range(N):
            s[i] = self.sample(E, rc)   
        return s
        #cdef int i
        #for i in range(N):
         #   self.sample(E)
        
def _getGrid():
    from numpy import array
    from os import listdir
    path = __path__ + f"/{1}/"

    files = listdir(path)
    for f in files:
        if ".pkl" in f:
            files.remove(f)

    
    
    allMU  = []

    
    with open(path + files[0], "r") as f:
        lines = f.readlines()

    MU = []
  
    for line in lines:
        if line[1] == "#":
            continue
                
        numb = line.split()
        mu = numb[1]
        MU.append(float(mu))
    return array(MU)


def getGrid():
    import pickle
    path = __path__ + "/grid.pkl"
    with open(path, 'rb') as pkl_file:
        data = pickle.load(pkl_file)
    return data


