# cython: profile=True
"""
DATABASE DOCUMENTATION: 
    https://www-nds.iaea.org/epics/DOCUMENTS/ENDL2002.pdf
    https://www-nds.iaea.org/epics/
"""

from numpy import * #array, geomspace, flip, load, searchsorted

from ..settings import __montecarlo__
from ..tools.data import getAxis
from ..tools.interpol1 import LinLinInterpolation

__materials__ = __montecarlo__/'materials'
directory = str(__materials__)



##################### CONSTANTS
Na = 6.02214129e23 #1/mol
c = 2.99792458e8
alpha = 1/137.035999074
hbar = 6.58211928e16 #eVs
e = 1.602176565e-19 #C
m_electron = 9.10938291e-31 #kg
E0_electron = 510.998928 #keV





class EADL:
    def __init__(self):
        
        self.container = [EADLelement(Z) for Z in range(1, 101)]
        
    
    def __getitem__(self, Z):
        return self.container[Z-1]
            




class EADLelement:
    def __init__(self, Z):
        self.Z = Z
        self.path = directory + "\\EADL\\" + str(Z) + ".txt"
        self.Aw, self.EADL_dict = self.getBookmarkedText()
        self.container = {}
        
        for Id in self.EADL_dict:
           if Id[0:3] == (0, 92, 91) and Id[4:] == (7, 931):
               j_, fr_, Er_ = [], [], []
               
               for line in self.EADL_dict[Id]:
                   j, fr, Er = [float(x) for x in line.split()]
                   
                   j_ += [j]
                   fr_ += [fr]
                   Er_ += [Er]
            
                
               self.container[Id] = tuple(map(array, (j_, fr_, Er_) ))
               
           if Id[0:3] == (0, 92, 91) and Id[4:] == (9, 932):
               j_, k_, fnr_, Enr_ = [], [], [], []
               
               for line in self.EADL_dict[Id]:
                   j, k, fnr, Enr = [float(x) for x in line.split()]
                   
                   j_ += [j]
                   k_ += [k]
                   fnr_ += [fnr]
                   Enr_ += [Enr]
            
                
               self.container[Id] = tuple(map(array, (j_, k_, fnr_, Enr_) ))
        
        
        

        
        
    def getBookmarkedText(self):
        path = self.path

        with open(path, "r") as file:
                text = file.readlines()
                text = [line.strip('\n') for line in text]

                bookmarks = [0]
                
                for n, line in enumerate(text):
                        if line == "                                                                       1":
                                bookmarks += [n + 1]
                                
                #gather all bookmarked text into a dict
                bookmark_ = bookmarks[0:-1]
                _ookmarks = bookmarks[1:]
                
                line0 = text[0]
                Z  = int(line0[0:3])
                Aw = float(line0[13:24])
                
        
                bookmarked_text = {}
                
                for i, j in zip(bookmark_, _ookmarks):
                        line1, line2 = text[i], text[i+1]
                        
                       #on line 1
                        Yi = float(line1[7:9])    #particle identifier
                        Yo = float(line1[10:12])  #secondary particle designator
                        
                        #on line 2
                        C  = float(line2[0:2])    #reaction descriptor
                        I  = float(line2[2:5])    #reaction property
                        S  = float(line2[5:8])    #reaction modifier
                        X1 = float(line2[22:32])  #subshell designator
                        
                        flags = (Yi, C, S, X1, Yo, I)

                        flags = tuple(map(int, flags))
                        bookmarked_text[flags] = text[i+2:j-1]
                        
        return Aw, bookmarked_text














def get_bookmarked_text_EADL(path):

    with open(path, "r") as file:
            text = file.readlines()
            text = [line.strip('\n') for line in text]

            bookmarks = [0]
            
            for n, line in enumerate(text):
                    if line == "                                                                       1":
                            bookmarks += [n + 1]
                            
            #gather all bookmarked text into a dict
            bookmark_ = bookmarks[0:-1]
            _ookmarks = bookmarks[1:]
            
            line0 = text[0]
            Z  = int(line0[0:3])
            Aw = float(line0[13:24])
            
    
            bookmarked_text = {}
            
            for i, j in zip(bookmark_, _ookmarks):
                    line1, line2 = text[i], text[i+1]
                    
                   #on line 1
                    Yi = float(line1[7:9])    #particle identifier
                    Yo = float(line1[10:12])  #secondary particle designator
                    
                    #on line 2
                    C  = float(line2[0:2])    #reaction descriptor
                    I  = float(line2[2:5])    #reaction property
                    S  = float(line2[5:8])    #reaction modifier
                    X1 = float(line2[22:32])  #subshell designator
                    
                    flags = (Yi, C, S, X1, Yo, I)

                    flags = tuple(map(int, flags))
                    bookmarked_text[flags] = text[i+2:j-1]
                    
    return Aw, bookmarked_text
















def getEADL(Z):
    """
    EADL DOC: 
        https://drive.google.com/file/d/1i5ndh-G6eD1ginpxNLzBtskJh3XTU5p9/
    """
    
    EADL_path      = directory + "\\EADL\\" + str(Z) + ".txt"
    
    Aw, EADL_dict = get_bookmarked_text_EADL(EADL_path)



    EADL_dict['Aw'] = Aw
    EADL_dict['Z']  = Z 
    

    
    
    return EADL_dict
    


		

    

































def getEPDL(Z):
    """
    DATABASE DOCS:
        https://drive.google.com/file/d/1_Dtsfd4A18m1BsZPCyWfm6PjcWxjyf1n/
        
    
    cullen1997
    https://drive.google.com/file/d/1WqppBrR-C3yiRuhp7P16c0yCPDFr2T9t/view?usp=sharing
    """
    
    EPDL_path      = directory + "\\EPDL\\" + str(Z) + ".txt"
    EPDL_dict = get_bookmarked_text(EPDL_path)
    
    

    for Id in EPDL_dict:
        EPDL_dict[Id] = Table(EPDL_dict[Id], Id, Z)
        
    
    return EPDL_dict

def getEEDL(Z):
    """
    DATABASE DOCS:
        https://drive.google.com/file/d/1ef8Ww_0PPWuLEuwpfv9KOF4wyd75_eOp/

    """
    
    EEDL_path = directory + r"\\EEDL\\" + str(Z) + ".txt"
    EEDL_dict = get_bookmarked_text(EEDL_path)
    
    
    for Id in EEDL_dict:
        EEDL_dict[Id] = EEDLtable(EEDL_dict[Id], Id, Z)
        
    return EEDL_dict

















def get_bookmarked_text(path):
        """
        Reads EPICS file format and returns a dict with flags as keys
        and data as a list of strings.
        """
        with open(path, "r") as file:
                text = file.readlines()
                text = [line.strip('\n') for line in text]

                bookmarks = [0]
                
                for n, line in enumerate(text):
                        if line == "                                                                       1":
                                bookmarks += [n + 1]
                                
                #gather all bookmarked text into a dict
                bookmark_ = bookmarks[0:-1]
                _ookmarks = bookmarks[1:]
        
                bookmarked_text = {}
                for i, j in zip(bookmark_, _ookmarks):
                        line1, line2 = text[i], text[i+1]

                        #on line 1
                        Yi = float(line1[7:9])    #particle identifier
                        Yo = float(line1[10:12])  #secondary particle designator
                        Iflag = float(line1[31])  #interpolation flag
                        
                        #on line 2
                        C  = float(line2[0:2])    #reaction descriptor
                        I  = float(line2[2:5])    #reaction property
                        S  = float(line2[5:8])    #reaction modifier
                        X1 = float(line2[22:32])  #subshell designator
                        
                        flags = (Yi, C, S, X1, Yo, I)

                        flags = tuple(map(int, flags))
                        bookmarked_text[flags] = (Iflag, text[i+2:j-1])
                        
        return bookmarked_text



# def get_bookmarked_text2(path):
#         """
#         Reads EPICS file format and returns a dict with flags as keys
#         and data as a list of strings.
#         """
#         with open(path, "r") as file:
#                 text = file.readlines()
#                 text = [line.strip('\n') for line in text]

#                 bookmarks = [0]
                
#                 for n, line in enumerate(text):
#                         if line == "                                                                       1":
#                                 bookmarks += [n + 1]
                                
#                 #gather all bookmarked text into a dict
#                 bookmark_ = bookmarks[0:-1]
#                 _ookmarks = bookmarks[1:]
        
#                 bookmarked_text = {}
#                 for i, j in zip(bookmark_, _ookmarks):
#                         line1, line2 = text[i], text[i+1]

#                         #on line 1
#                         Z = float(line1[0:3])     #
#                         A = float(line1[3:6])  #secondary particle designator
#                         Yi = float(line1[7:9])  #interpolation flag
#                         Yo = float(line1[10:12])
#                         AW = float(line1[13:24])
                        
#                         #on line 2
#                         #C  = float(line2[0:2])    #reaction descriptor
#                         #I  = float(line2[2:5])    #reaction property
#                         #S  = float(line2[5:8])    #reaction modifier
#                         #X1 = float(line2[22:32])  #subshell designator
                        
#                         flags = int(Z)

#                         #flags = tuple(map(int, flags))
#                         bookmarked_text[flags] =  text[i+2:j-1]
                        
#         return bookmarked_text











class Table:
    
    IDtranslation = {(7, 71, 0, 0, 0, 0): "Coherent",
                     (7, 71, 0, 0, 7, 10): "FormFactor",
                     (7, 72, 0, 0, 0, 0): "Incoherent",
                     (7, 72, 0, 0, 7, 10): "IncoherentFormFactor",
                     (7, 72, 0, 0, 9, 10): "???",
                     (7, 73, 0, 0, 0, 0): "???",
                     (7, 73, 91, 1, 0, 0): "???",
                     (7, 73, 91, 1, 0, 11): "???",
                     (7, 73, 91, 1, 9, 10): "???",
                     (7, 74, 0, 0, 0, 0): "???",
                     (7, 74, 0, 0, 8, 10): "???",
                     (7, 74, 0, 0, 9, 10): "???",
                     (7, 75, 0, 0, 0, 0): "???",
                     (7, 75, 0, 0, 8, 10): "???",
                     (7, 75, 0, 0, 9, 10): "???",
                     (7, 93, 0, 0, 0, 941): "???",
                     (7, 93, 0, 0, 0, 942): "???",
                     (7, 93, 0, 0, 0, 943): "???",
                     (7, 93, 0, 0, 0, 944): "???"}
    
    def __init__(self, EPDLtable, Id, Z):
        
   
        self.Z = Z
        self.Id = Id
        #print(EPDLtable)
        self.Iflag, rawData = EPDLtable[0], EPDLtable[1]
        
        try:    self.X, self.Y = getAxis(rawData)
        except: self.rawData = rawData
    
    def getLinLinInterpol(self):
        return LinLinInterpolation(self.X, self.Y)

    def getLogLogInterpol(self):
        
        f = self.getLinLinInterpol()
        
        x_min, x_max = min(self.X), max(self.X)
        X_logspaced = logspace(x_min, x_max, num=100)
        
        Y_logspaced = [f(x) for x in X_logspaced]
        Y_logspaced = array(X_logspaced)
        
        return LogLogInterpol(X_logspaced, Y_logspaced)

    def scatter(self):
        import matplotlib.pyplot as plt
        fig = plt.figure(figsize=(10, 10))
        plt.scatter(self.X, self.Y, s=3)
        plt.xscale("log")
        plt.yscale("log")
        plt.title("EADL table id = " + str(self.Id) + f" of element {self.Z}")
        plt.grid(which = 'both')
        plt.show()




class EEDLtable:
    
    
    def __init__(self, table, Id, Z):
        
        self.Z = Z
        self.Id = Id
        #print(EPDLtable)
        self.Iflag, rawData = table[0], table[1]
        Ncolumns = len(rawData[0].split())
        self.Ncolumns = Ncolumns
        if Ncolumns == 2:
            self.X, self.Y = getAxis(rawData)
            return

    
        axis1 = []
        axis2 = []
        axis3 = []
        
        for line in rawData:
            numbers = [float(x) for x in line.split()]
            axis1 += [numbers[0]]
            axis2 += [numbers[1]]
            axis3 += [numbers[2]]
        
        self.E = array(axis1)
        
        
        self.Y1 = {E:[] for E in self.E}
        self.Y2 = {E:[] for E in self.E}
        for i, E in enumerate(self.E):
            self.Y1[E].append(axis2[i])
            self.Y2[E].append(axis3[i])
            

    
            


    def scatter(self, E):
        import matplotlib.pyplot as plt
        fig = plt.figure(figsize=(10, 10))
        plt.scatter(self.Y1[E], self.Y2[E], s=3)
        plt.xscale("log")
        plt.yscale("log")
        plt.title("EADL table id = " + str(self.Id) + f" of element {self.Z}")
        plt.grid(which = 'both')
        plt.show()

            






class EPDL:
    __cache__ = {}
    def __getitem__(self, Z):
        try:
            return self.__cache__[Z+1]
        except KeyError:
            self.__cache__[Z+1] = getEPDL(Z+1)
            return self.__cache__[Z+1]
    def __call__(self, Z):
        try:
            return self.__cache__[Z-1]
        except KeyError:
            self.__cache__[Z-1] = getEPDL(Z)
            return self.__cache__[Z-1]
    
        
    
class EEDL:
    __cache__ = {}
    def __getitem__(self, Z):
        try:
            return self.__cache__[Z+1]
        except KeyError:
            self.__cache__[Z+1] = getEEDL(Z+1)
            return self.__cache__[Z+1]
        
    def __call__(self, Z):
        try:
            return self.__cache__[Z-1]
        except KeyError:
            self.__cache__[Z-1] = getEEDL(Z)
            return self.__cache__[Z-1]
    
















import pickle

if True:
    print("""
    ________________
    > Reading EADL. """)
    #EADL = EADL()
    EADL = [getEADL(Z) for Z in range(1, 101)]
    print("""> Done! EPDL available @ database.EPDL
    ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯""")


    
    EPDL = EPDL()
    
    print("""
    ________________
    > Reading EPDL. """)
    #EPDL = [getEPDL(Z) for Z in range(1, 101)] 
    print("""> Done! EPDL available @ database.EPDL
    ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯""")
        
    EEDL = EEDL()
    
    print("""
    ________________
    > Reading EEDL. """)
    
    #EEDL = EEDL()
    #EEDL = [getEEDL(Z) for Z in range(1, 101)]
    print("""> Done! EPDL available @ database.EEDL
    ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
    """)
    
    
    print("Imported databases")


    data = [EADL, EPDL, EEDL]


    with open(directory + "\\data.pkl", 'wb') as output:
        pickle.dump(data, output)
        
    print("Saved database.")
else:
    with open(directory + "\\data.pkl", 'rb') as pkl_file:
        data = pickle.load(pkl_file)
    
    EADL, EPDL, EEDL = data




