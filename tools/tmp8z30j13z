# cython: profile=True




from . cimport search

import numpy as np



cimport cython
#@cython.boundscheck(False)  # Deactivate bounds checking
#@cython.wraparound(False)   # Deactivate negative indexing.
def newLinLinInterpolation(xAxis, yAxis):
    return LinLinInterpolation(xAxis, yAxis)




@cython.initializedcheck(False)
@cython.cdivision(True)
@cython.boundscheck(False)  # Deactivate bounds checking
@cython.wraparound(False)   # Deactivate negative indexing.
cdef class LinLinInterpolation:
    #cdef double [:] xAxis, yAxis, m
    #cdef int N
    
    
    def __init__(self, xAxis, yAxis):
        xAxis, yAxis = map(np.array, (xAxis, yAxis))
        
        DIFFS = np.diff(xAxis)
        
        INCLUDE = np.array([True] + list(DIFFS != 0)) 
        self._xAxis = xAxis[INCLUDE]
        self._yAxis = yAxis[INCLUDE]
        self._N = len(self._xAxis)    
        self._m = np.diff(self._yAxis)/np.diff(self._xAxis)
        self._xMIN = np.min(self._xAxis)
        self._xMAX = np.max(self._xAxis)
        
        
        
    
    
    cdef double _eval(self, double x):
        #print(self.xAxis)n
        
        if x < self._xMIN:
            return 0
        
        if x > self._xMAX:
            return 0
        
        
        cdef int i = search._sortedArrayDOUBLE(self._xAxis, x, 0, self._N)
        
        
        #i = searchsorted(self.xAxis, x)
        return self._yAxis[i] + self._m[i]*(x - self._xAxis[i])
    
    
    def eval(self, double x):
        return self._eval(x)
    
    
    #PYTHON INTERFACE
    def __call__(self, double x):
        return self._eval(x)
    
    
    @property
    def xAxis(self):
        return self._xAxis
    
    @property
    def yAxis(self):
        return self._yAxis
    
    @property
    def N(self):
        return self._N
    
    @property
    def yMAX(self):
        return self._yMAX
    
    @property
    def xMAX(self):
        return self._xMAX
    
    
    
from libc.math cimport log10



import numpy as np


cimport cython

@cython.initializedcheck(False)
@cython.cdivision(True)
@cython.boundscheck(False)  # Deactivate bounds checking
@cython.wraparound(False)   # Deactivate negative indexing.
cdef class LogLinInterpolation:

    
    """
    xAxis is logspaced
    """
    def __init__(self, xAxis, yAxis):
        xAxis, yAxis = map(np.array, (xAxis, yAxis))
        
        DIFFS = np.diff(xAxis)
        
        INCLUDE = np.array([True] + list(DIFFS != 0)) 
        self._xAxis = xAxis[INCLUDE]
        self._yAxis = yAxis[INCLUDE]
        self._N = len(self._xAxis)    
        self._m = np.diff(self._yAxis)/np.diff(self._xAxis)
        self._xMIN = np.min(self._xAxis)
        self._xMAX = np.max(self._xAxis)
        
        
        
    
    
    cdef double _eval(LogLinInterpolation self, double x):
        #print(self.xAxis)n
        x = log10(x)
        
        if x < self._xMIN:
            return 0
        
        if x > self._xMAX:
            return 0
        
        
        cdef int i = search._sortedArrayDOUBLE(self._xAxis, x, 0, self._N)
        
        
        #i = searchsorted(self.xAxis, x)
        return self._yAxis[i] + self._m[i]*(x - self._xAxis[i])
    
    
    def eval(LogLinInterpolation self, double x):
        return self._eval(x)
    
    
    #PYTHON INTERFACE
    def __call__(LogLinInterpolation self, double x):
        return self._eval(x)
    
    
    @property
    def xAxis(self):
        return self._xAxis
    
    @property
    def yAxis(self):
        return self._yAxis
    
    @property
    def N(self):
        return self._N
    
    @property
    def yMAX(self):
        return self._yMAX
    
    @property
    def xMAX(self):
        return self._xMAX
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
class LogLogInterpolation:
    def __init__(self, xAxis, yAxis):
        self.xAxis, self.yAxis = map(np.array, (xAxis, yAxis))
        self.xAxis, self.yAxis = map(np.log10, (xAxis, yAxis))
        
        self.m = np.diff(self.yAxis)/np.diff(self.xAxis)
        
    def __call__(self, x):
        #print(self.xAxis)
        i = np.searchsorted(self.xAxis, x)
        return 10**(self.yAxis[i] + self.m[i]*(x - self.xAxis[i]))












from scipy.integrate import quad
from numpy.random import rand
from numpy import searchsorted
#from numpy import logspace, log10, array
import cython




@cython.boundscheck(False)  # Deactivate bounds checking
@cython.wraparound(False)   # Deactivate negative indexing.
cdef class InvRationalInterpolation:

    
    def __init__(self, f:callable, x0:float, xf:float):
        """
        f -> cubic spline interpolation
        """
        
        A = f.integrate(x0, xf)
        self.p = lambda x: f(x)/A
        self.c = lambda x: f.integrate(x0, x)/A
        
        
        #self.p = normalize(f, x0, xf)
        #self.c = make_cumul(f, x0, xf)
        
        self.X = np.logspace(log10(x0), log10(xf), 500)
        self.C = np.array([self.c(x) for x in self.X])
        self.Npoints = len(self.C)
        
        #self.X = [x0 + rand()*(xf-x0) for _ in range(10)]
        
       
        
        self.params = []
        for i in range(len(self.C)-1):
            self.params.append( self.getab(i) )
            
        self.Nparams = len(self.params)
    
    
    def b(self, int i):
        C, X, p = self.C, self.X, self.p
        
        dC = C[i+1] - C[i]
        dx = X[i+1] - X[i]
        
        return 1 - (dC/dx)**2 / p(X[i+1]) / p(X[i])
    
    def getab(self, int i):
        C, X, p = self.C, self.X, self.p
        
        cdef double dC = C[i+1] - C[i]
        cdef double dx = X[i+1] - X[i]
        
        cdef double b = self.b(i)
        
        return dC/dx / p(X[i]) - b - 1, b
    
    cdef double _eval(self, double r):
        cdef int i = search._sortedArrayDOUBLE(self.C, r, 0, self.Npoints)
        
        if i > self.Nparams-1:
            return 1
        
        cdef double a, b
        a, b = self.params[i]
        
        cdef double nu = (r - self.C[i])/(self.C[i+1] - self.C[i])
        
        cdef double A = (1 + a + b)*nu
        cdef double B = 1 + a*nu + b*nu**2
        
        cdef double x0 = self.X[i]
        cdef double xf = self.X[i+1]
        
        return x0 + A/B * (xf-x0)        

    def eval(self, double r):
        return self._eval(r)
    
    def __call__(self, r):
        i = search._sortedArrayDOUBLE(self.C, r, 0, len(self.C))
        #i = searchsorted(self.C, r, side="right") + 1
        if i > len(self.params)-1:
            return 1
        
        
        a, b = self.params[i]
        
        nu = (r - self.C[i])/(self.C[i+1] - self.C[i])
        
        A = (1 + a + b)*nu
        B = 1 + a*nu + b*nu**2
        
        x0 = self.X[i]
        xf = self.X[i+1]
        
        return x0 + A/B * (xf-x0)


























# class LinearInterpolation:
#     def __init__(self, xAxis, yAxis):

#         self.xAxis = xAxis
#         self.yAxis = yAxis

#         N = len(xAxis)

#         self.intervals = [] 

#         for i in range(N-1):
#             x0, xf = xAxis[i], xAxis[i+1]
#             y0, yf = yAxis[i], yAxis[i+1]
#             self.intervals += [Interval(x0, xf, y0, yf)]

#     def __call__(self, x):
#         if x == self.xAxis[0]: return self.xAxis[0]
#         k = searchsorted(self.xAxis, x)
#         return self.intervals[k-1](x)

# cdef class Interval:
#     def __init__(self, x0, xf, y0, yf):
#         self.m = (yf-y0)/(xf-x0)
#         self.x0, self.xf = x0, xf
#         self.y0, self.yf = y0, yf

#     def __call__(self, x):
#         return self.y0 + self.m * (x - self.x0)

#     def __contains__(self, x):
#         return self.x0 <= x < self.xf

#     def __repr__(self):
#         return str((self.x0, self.yf))
#     def __str__(self):
#         return self.__repr__()

