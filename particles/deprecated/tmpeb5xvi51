# cython: profile=True
# cython: annotate=True


#Error messages (to be moved to its own module)
errorMSG1 = "Exhausted allowed number of iterations for rejection sampling."

#External Imports
from numpy import *
from numpy.random import rand, randint
#import pickle -> probly not needed any more?


#Local Imports
from .particle import StopSimulation
from .particle cimport Particle
from ..tools.vectors cimport Vector
from ..materials import database as db
# --  -- from . import electrons as e


#settings
from ..settings import __photonCUTOFF__



#CONSTANTS

cdef double E0_el = db.E0_electron*1e-3



cdef object choose(list cumul, list items):

    cdef double r = rand()*cumul[-1]
    cdef int i = 0

    for i in range(len(cumul)):
        if cumul[i] > r:
            return items[i-1]



cdef class Photon(Particle):
    cdef double k

    cdef int N_coh, N_incoh, N_photo, N_pair, N_trip

    cdef list  _interactions
    cdef list  interactions

    #cdef object current_material
    #cdef double imfp_T
   # cdef list   imfp_cumul

    cdef object coherent, incoherent, photoelectric
    cdef object pairproduction, tripletproduction, inter



    cdef list X, Y, Z


    def __init__(self, space, current_region,
                 E     = 6.,
                 pos   = Vector(0., 0., 0.),
                 theta = 0.,
                 phi   = 0.,
                 ex    = Vector(1., 0., 0.), 
                 ey    = Vector(0., 1., 0.), 
                 ez    = Vector(0., 0., 1.),
                 simulate_secondary = False):

        self.k = E/E0_el

        self._interactions = [self._coherent, self._incoherent,  self._photoelectric, self._pairproduction, self._tripletproduction]

        self.X, self.Y, self.Z = [], [], []


        super().__init__(space, E, pos, 
                         theta, phi, 
                         ex, ey, ez, 
                         simulate_secondary,
                         current_region)
        
        self.update_references()

    #@timer

    def run(self):
        return self._run()



    cdef tuple _run(self):
        try:
            while 1:
                self.X += [self.pos.x]
                self.Y += [self.pos.y]
                self.Z += [self.pos.z]
                
                self.propagate()
                #print(self.mu_cumul)
                #self.mu_tot = 0.

                self.inter = choose(self.imfp_cumul, self._interactions)

                self.inter(self)


        except StopSimulation:
            self.X += [self.pos.x]
            self.Y += [self.pos.y]
            self.Z += [self.pos.z]
            self.E = E0_el*self.k
            if self.simulate_secondary is True:
                if self.children is not None:
                    for particle in self.children_[1:]:
                        particle.simulate_secondary = True
                        particle.run()
            return (X, Y, Z)



    cdef update_references(self):
        """
        Updates all references. Usually called when there is a region crossing.
        """
        #print(self.current_region.material)
        self.current_material = self.current_region.material.photon
        
        #these references are used by their corresponding _fooInteraction method
        self.coherent          = self.current_material.coherent
        self.incoherent        = self.current_material.incoherent
        self.photoelectric     = self.current_material.photoelectric
        self.pairproduction    = self.current_material.pairproduction
        self.tripletproduction = self.current_material.tripletproduction


        #this list is used so I can iterate over all interactions
        #to create the cumulutative list
        self.interactions = [self.coherent, 
                             self.incoherent,
                             self.photoelectric,
                             self.pairproduction,
                             self.tripletproduction]
        
        self.update_imfp()
        #print(self.imfp_cumul)



    cdef update_imfp(self):
        """
        Updates cross sections. Called when there is a region crossing or
        when the value of energy has changed.
        """

        self.imfp_T   = 0.
        self.imfp_cumul = [0.]

        self.E = self.k * E0_el

        for interaction in self.interactions:
            self.imfp_T   += interaction.mfp(self.E)
            self.imfp_cumul += [self.imfp_T]





    def summary(self):
        print(f"coh: {self.N_coh} \n incoh: {self.N_incoh}")
        print(f"pair: {self.N_pair} \n trip: {self.N_trip}")












    cdef _coherent(self):
        """
        - Samples angular deflection for the coherent scattering.
        - Changes direction accordingly.

        To do: Low energy stuff.
        """

        self.N_coh += 1
        
        cdef double r, x2, cos
        cdef double x_max = 20.6074*2*self.k
        cdef double r_max = self.coherent.FF.cumul(x_max) #internals of this needs work
        
        while 1:
            #Sample x**2 from squared form factor (limited in (0, x_max**2))
            r  = rand()*r_max

            x2 = self.coherent.FF.invCum(r)

            #Get cos(theta) from x**2 and k = E/0.511MeV
            cos  = 1 - 0.5 * x2 / (20.6074*self.k)**2

            #Sample from thomson scattering.
            if rand() < (1+cos**2)*.5:
                self.change_direction(cos, 2*pi*rand())
                break


    cdef _incoherent(self):
        """
        Incoherent sampling.
        """

        self.N_incoh += 1
        
        cdef double t1 = log(1 + 2*self.k)
        cdef double t2 = 2*self.k*(1 + self.k)/(1 + 2*self.k)**2
        cdef double tau_min = 1/(1 + 2*self.k)
        cdef double tau, cos, N, D, sin2, x , T
        
        cdef int _
        for _ in range(10_000):

            #Sample fractional energy loss(tau)
            if rand() < t1/(t1 + t2): tau = tau_min**rand()
            else:                     tau = (tau_min**2 + rand()*(1 - tau_min**2))**.5

            #Calculate cosine from current energy and tau
            cos = (self.k + 1 - 1/tau)/self.k

            #constructing eqn in braces
            N = (1 - tau)*( (2 * self.k + 1) * tau - 1)
            D = self.k**2 * tau * (1 + tau**2)

            #constructing argument for Incoherent Form Factor
            sin2 = (.5 * (1 - cos))**.5
            x = self.k*sin2*2*20.6074
            
            #calculating proposal
            T = (1 - N/D)*self.incoherent.S(x)

            if rand() < T:
                self.change_direction(cos, 2*pi*rand())
                self.k = tau*self.k
                self.update_imfp()
                if self.k < __photonCUTOFF__: #note to self: make cut off adjustable
                    raise StopSimulation
                
                break
        else: 
            print("k =", self.k)
            raise RuntimeError("Incoherent Scattering Sampling: " + errorMSG1)






    cdef _pairproduction(self):
        self.N_pair += 1
        
        
        #SAMPLING ENERGY OF POSITRON AND ELECTRON
        
        cdef double u1, u2, phiHalf_1, phiHalf_2, phi1, phi2
        cdef int i
        
        while True:
            phiHalf_1, phiHalf_2 = self.pairproduction.getPhis(.5, self.k)

            u1 = phiHalf_1 * (2/3) * (.5 - 1/self.k)**2
            u2 = phiHalf_2
        
            i = 1 if (u1 + u2)*rand() < u1 else 2
            
            if i == 1:
                eps  = .5 + (.5 - 1/self.k)*(2*rand() - 1)**(1/3)
                phi1, phi2 = self.pairproduction.getPhis(eps, self.k)

                if rand() < phi1/phiHalf_1:
                    break

            else:
                eps = 1/self.k + (.5 - 1/self.k)*2*rand()
                phi1, phi2 = self.pairproduction.getPhis(eps, self.k)

                if rand() < phi2/phiHalf_2:
                    break
        
        #SAMPLE THEIR DIRECTION
        # azimuth of both is unif distributed and independent
        
        cdef double E = self.k*E0_el
        
        cdef double Eminus = eps*E - E0_el
        cdef double Eplus  =  E - Eminus - 2*E0_el
        
        
        cdef double beta_p = sqrt(Eplus * (Eplus + 2*E0_el))   / (Eplus + E0_el)
        cdef double beta_m = sqrt(Eminus * (Eminus + 2*E0_el)) / (Eminus + E0_el)
        
        cdef double r = 2*rand() - 1
        cdef double cos_p = (r + beta_p)/(r*beta_p + 1)

        r = 2*rand() - 1
        cdef double cos_m = (r + beta_m)/(r*beta_m + 1)
        
        cdef double phi_p = 2*pi*rand()
        cdef double phi_m = 2*pi*rand()
        
        raise StopSimulation
        


    cdef _photoelectric(self):
        self.N_photo += 1
        
        cdef dict formula = self.current_material.molecule.formula
        cdef double E = self.k*0.511
        cdef list PROB = [atom.CS(E)*formula[atom] for atom in formula]
        
        cdef double A = sum(PROB)
        
        PROB = [p/A for p in PROB]
        
        cdef list cumul = [0]
        cdef double q = 0
        
        for p in PROB:
            q += p
            cumul.append(q)
            
            
        cdef object atom = choose(cumul, list(formula))
        
        PROB = [shell.CS(E) for shell in atom]
        
        A = sum(PROB)
        
        PROB = [p/A for p in PROB]
        
        cumul = [0]
        q = 0
        
        for p in PROB:
            q += p
            cumul.append(q)
        
        
        atom._introduceVacancy(choose(cumul, atom.SHELLS))
        atom.run()
        
        raise StopSimulation
        
        
        
        #first select the element that will be ionized
        cdef list P = [0.]
        cdef double Ptot = 0.
        cdef list elements = []

        for element in self.photoelectric:
            elements += [element]
            Ptot     += element(self.k*E0_el)
            P        += [Ptot]

        element = choose(P, elements) #element that will be ionized

        #then select the active shell
        P = [0.]
        Ptot = 0.
        cdef shells = []
        for shell in element:
            shells += [shell]
            Ptot += shell(self.k*E0_el)
            P    += [Ptot]

        shell = choose(P, shells)        
        raise StopSimulation



    def __repr__(self):
        return f"<Photon: pos = {self.pos}, ez = {self.ez}, k = {self.k}>"


    cdef _tripletproduction(self):
        self.N_trip += 1
        self._pairproduction()


        
