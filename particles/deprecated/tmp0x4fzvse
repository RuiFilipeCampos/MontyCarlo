# cython: profile=True
# cython: annotate=True


#Error messages (to be moved to its own module)
errorMSG1 = "Exhausted allowed number of iterations for rejection sampling."

#External Imports
from numpy import *
#from numpy.random import rand, randint
#import pickle -> probly not needed any more?


#Local Imports
from .particle import StopSimulation
from .particle cimport Particle
from ..tools.vectors cimport Vector
from ..materials import database as db
# --  -- from . import electrons as e
from libc.math cimport sin, cos, log, sqrt


#settings
from ..settings import __photonCUTOFF__


cdef double CUTOFF = __photonCUTOFF__



from libc.stdlib cimport rand as randint
from libc.stdlib cimport RAND_MAX


cdef double rand():
    cdef double r = randint()
    return r/RAND_MAX


cdef struct INCOHERENT:
    double t1
    double t2
    double tau_min
    double tau, cos, N, D, sin2, x , T
    double k

cdef INCOHERENT INCOH




#CONSTANTS

cdef double E0_el = db.E0_electron*1e-3

cimport cython
@cython.boundscheck(False)  # Deactivate bounds checking
@cython.wraparound(False)   # Deactivate negative indexing.


cdef object choose(list cumul, list items):
    cdef int N = len(cumul)
    
    cdef double r = rand()*cumul[N-1]
    cdef int i = 0

    for i in range(N):
        if cumul[i] > r:
            return items[i-1]


cdef int chooseI(list cumul, int N):
    #cdef int N = len(cumul)
    
    cdef double r = rand()*cumul[N-1]
    cdef int i = 0

    for i in range(N):
        if cumul[i] > r:
            return i-1





cdef class Photon(Particle):
    cdef double k

    cdef int N_coh, N_incoh, N_photo, N_pair, N_trip

    cdef list  _interactions
    cdef list  interactions

    #cdef object current_material
    #cdef double imfp_T
   # cdef list   imfp_cumul

    cdef object coherent, incoherent, photoelectric
    cdef object pairproduction, tripletproduction, inter



    cdef list X, Y, Z


    def __init__(self, space, current_region,
                 E     = 6.,
                 pos   = Vector(0., 0., 0.),
                 theta = 0.,
                 phi   = 0.,
                 ex    = Vector(1., 0., 0.), 
                 ey    = Vector(0., 1., 0.), 
                 ez    = Vector(0., 0., 1.),
                 simulate_secondary = False):

        self.k = E/E0_el

        self._interactions = [self._coherent, 
                              self._incoherent,  
                              self._photoelectric, 
                              self._pairproduction, 
                              self._tripletproduction]
        
        #print(self._interactions)

        self.X, self.Y, self.Z = [], [], []


        super().__init__(space, E, pos, 
                         theta, phi, 
                         ex, ey, ez, 
                         simulate_secondary,
                         current_region)
        
        self.update_references()

    #@timer

    def run(self):
        return self._run()



    cdef _run(self):
        cdef int I
        try:
            while 1:
                self.X.append(self.pos.x)
                self.Y.append(self.pos.y)
                self.Z.append(self.pos.z)
                
                self.propagate()
                #print(self.mu_cumul)
                #self.mu_tot = 0.



                I = chooseI(self.imfp_cumul, 6)
                
                self._interactions[I](self)


        except StopSimulation:
            self.X.append(self.pos.x)
            self.Y.append(self.pos.y)
            self.Z.append(self.pos.z)
            
            self.E = E0_el*self.k
            
            if self.simulate_secondary is True:
                if self.children is not None:
                    for particle in self.children_[1:]:
                        particle.simulate_secondary = True
                        particle.run()
            #return (self.X, self.Y, self.Z)


    
    def getTrack(self):
        return self.X, self.Y, self.Z


    cdef update_references(self):
        """
        Updates all references. Usually called when there is a region crossing.
        """
        #print(self.current_region.material)
        self.current_material = self.current_region.material.photon
        
        #these references are used by their corresponding _fooInteraction method
        self.coherent          = self.current_material.coherent
        self.incoherent        = self.current_material.incoherent
        self.photoelectric     = self.current_material.photoelectric
        self.pairproduction    = self.current_material.pairproduction
        self.tripletproduction = self.current_material.tripletproduction


        #this list is used so I can iterate over all interactions
        #to create the cumulutative list
        self.interactions = [self.coherent, 
                             self.incoherent,
                             self.photoelectric,
                             self.pairproduction,
                             self.tripletproduction]
        
        self.update_imfp()
        #print(self.imfp_cumul)



    cdef update_imfp(self):
        """
        Updates cross sections. Called when there is a region crossing or
        when the value of energy has changed.
        """

        self.imfp_T   = 0.
        self.imfp_cumul = [0.]

        self.E = self.k * E0_el

        for interaction in self.interactions:
            self.imfp_T   += interaction.mfp(self.E)
            self.imfp_cumul += [self.imfp_T]





    def summary(self):
        print(f"coh: {self.N_coh} \n incoh: {self.N_incoh}")
        print(f"pair: {self.N_pair} \n trip: {self.N_trip}")












    cdef _coherent(self):
        """
        - Samples angular deflection for the coherent scattering.
        - Changes direction accordingly.

        To do: Low energy stuff.
        """

        self.N_coh += 1
        
        cdef double r, x2, cos
        cdef double x_max = 20.6074*2*self.k
        cdef double r_max = self.coherent.FF.cumul(x_max) #internals of this needs work
        
        while 1:
            #Sample x**2 from squared form factor (limited in (0, x_max**2))
            r  = rand()*r_max

            x2 = self.coherent.FF.invCum(r)

            #Get cos(theta) from x**2 and k = E/0.511MeV
            cos  = 1 - 0.5 * x2 / (20.6074*self.k)**2

            #Sample from thomson scattering.
            if rand() < (1+cos**2)*.5:
                self.change_direction(cos, 2*pi*rand())
                break


    cdef _incoherent(self):
        """
        Incoherent sampling.
        """

        self.N_incoh += 1
        
        INCOH.t1 = log(1 + 2*self.k)
        INCOH.t2 = 2*self.k*(1 + self.k)/(1 + 2*self.k)**2
        INCOH.tau_min = 1/(1 + 2*self.k)
        INCOH.k = self.k
        
        #cdef int _
        while 1:

            #Sample fractional energy loss(tau)
            if rand() < INCOH.t1/(INCOH.t1 + INCOH.t2): INCOH.tau = INCOH.tau_min**rand()
            else:                     INCOH.tau = (INCOH.tau_min**2 + rand()*(1 - INCOH.tau_min**2))**.5

            #Calculate cosine from current energy and tau
            INCOH.cos = (INCOH.k + 1 - 1/INCOH.tau)/INCOH.k

            #constructing eqn in braces
            INCOH.N = (1 - INCOH.tau)*( (2 * INCOH.k + 1) * INCOH.tau - 1)
            INCOH.D = INCOH.k**2 * INCOH.tau * (1 + INCOH.tau**2)

            #constructing argument for Incoherent Form Factor
            INCOH.sin2 = (.5 * (1 - INCOH.cos))**.5
            INCOH.x = INCOH.k*INCOH.sin2*2*20.6074
            
            #calculating proposal
            INCOH.T = (1 - INCOH.N/INCOH.D)*self.incoherent.S(INCOH.x)

            if rand() < INCOH.T:
                self.change_direction(INCOH.cos, 2*pi*rand())
                self.k = INCOH.tau*INCOH.k
                self.update_imfp()
                if self.k < CUTOFF:
                    raise StopSimulation
                
                break
        #else: 
        #    print("k =", self.k)
        #    raise RuntimeError("Incoherent Scattering Sampling: " + errorMSG1)






    cdef _pairproduction(self):
        self.N_pair += 1
        
        
        #SAMPLING ENERGY OF POSITRON AND ELECTRON
        
        cdef double u1, u2, phiHalf_1, phiHalf_2, phi1, phi2
        cdef int i
        
        while True:
            phiHalf_1, phiHalf_2 = self.pairproduction.getPhis(.5, self.k)

            u1 = phiHalf_1 * (2/3) * (.5 - 1/self.k)**2
            u2 = phiHalf_2
        
            i = 1 if (u1 + u2)*rand() < u1 else 2
            
            if i == 1:
                eps  = .5 + (.5 - 1/self.k)*(2*rand() - 1)**(1/3)
                phi1, phi2 = self.pairproduction.getPhis(eps, self.k)

                if rand() < phi1/phiHalf_1:
                    break

            else:
                eps = 1/self.k + (.5 - 1/self.k)*2*rand()
                phi1, phi2 = self.pairproduction.getPhis(eps, self.k)

                if rand() < phi2/phiHalf_2:
                    break
        
        #SAMPLE THEIR DIRECTION
        # azimuth of both is unif distributed and independent
        
        cdef double E = self.k*E0_el
        
        cdef double Eminus = eps*E - E0_el
        cdef double Eplus  =  E - Eminus - 2*E0_el
        
        
        cdef double beta_p = sqrt(Eplus * (Eplus + 2*E0_el))   / (Eplus + E0_el)
        cdef double beta_m = sqrt(Eminus * (Eminus + 2*E0_el)) / (Eminus + E0_el)
        
        cdef double r = 2*rand() - 1
        cdef double cos_p = (r + beta_p)/(r*beta_p + 1)

        r = 2*rand() - 1
        cdef double cos_m = (r + beta_m)/(r*beta_m + 1)
        
        cdef double phi_p = 2*pi*rand()
        cdef double phi_m = 2*pi*rand()
        
        raise StopSimulation
        


    cdef _photoelectric(self):
        self.N_photo += 1
        
        cdef dict formula = self.current_material.molecule.formula
        cdef double E = self.k*0.511
        cdef list PROB = [atom.CS(E)*formula[atom] for atom in formula]
        
        cdef double A = sum(PROB)
        
        PROB = [p/A for p in PROB]
        
        cdef list cumul = [0]
        cdef double q = 0
        
        for p in PROB:
            q += p
            cumul.append(q)
            
        cdef int I = chooseI(cumul, len(cumul))
        cdef object atom = list(formula)[I]
        
        PROB = [shell.CS(E) for shell in atom]
        
        A = sum(PROB)
        
        PROB = [p/A for p in PROB]
        
        cumul = [0]
        q = 0
        
        for p in PROB:
            q += p
            cumul.append(q)
        
        
        I = chooseI(cumul, len(cumul))
 
        
        atom.ionize(atom.SHELLS[I])
        atom.run()
        
        raise StopSimulation
        
        
        
        #first select the element that will be ionized
        cdef list P = [0.]
        cdef double Ptot = 0.
        cdef list elements = []

        for element in self.photoelectric:
            elements += [element]
            Ptot     += element(self.k*E0_el)
            P        += [Ptot]

        element = choose(P, elements) #element that will be ionized

        #then select the active shell
        P = [0.]
        Ptot = 0.
        cdef shells = []
        for shell in element:
            shells += [shell]
            Ptot += shell(self.k*E0_el)
            P    += [Ptot]

        shell = choose(P, shells)        
        raise StopSimulation



    def __repr__(self):
        return f"<Photon: pos = {self.pos}, ez = {self.ez}, k = {self.k}>"


    cdef _tripletproduction(self):
        self.N_trip += 1
        self._pairproduction()


        
