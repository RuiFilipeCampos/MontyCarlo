#cython: profile = False



import numpy as np #array, geomspace, flip, load, searchsorted
from numpy.random import *

#from ..particles.photons import choose
from ..settings import __montecarlo__, __photonCUTOFF__, __electronCUTOFF__

cdef double photonCUTOFF = __photonCUTOFF__
cdef double electronCUTOFF = __electronCUTOFF__*1e-6


from ..tools.data import getAxis, getTable
from ..tools.interpol1 import LinLinInterpolation
from ..tools cimport search

from ..particles.electrons cimport Electron
from ..particles.photons cimport Photon


from . import database as db

__materials__ = __montecarlo__/'materials'


cdef str directory = str(__materials__)

from numpy import searchsorted, concatenate, append



cimport cython

@cython.boundscheck(True)  # Deactivate bounds checking
@cython.wraparound(False)   # Deactivate negative indexing.
cdef object choose(list cumul, list items):

    cdef double r = rand()*cumul[-1]
    cdef int i = 0


    for i in range(len(cumul)):
        if cumul[i] > r:
            return items[i-1]


cdef int chooseI(list cumul, int N):
    #cdef int N = len(cumul)
    
    cdef double r = rand()*cumul[N-1]
    cdef int i = 0

    for i in range(N):
        if cumul[i] > r:
            return i-1


from ..tools.interpol1 cimport LinLinInterpolation

cimport numpy as cnp


cdef class Shell:
    
    def __init__(self, *args, **kwargs):
        
        self.Nvac = 0
        
        self.args = args
        self.i, self.Nel, self.binding_energy, self.KE, self.avgR, self.Z = args
        self.CS = db.EPDL[self.Z-1][(7, 73, 91, self.i, 0, 0)].getLinLinInterpol()

        self.kwargs = kwargs
        self.rTrans = kwargs['rTrans']
        self.nrTrans = kwargs['nrTrans']
        
        if (self.rTrans  is not None) and \
           (self.nrTrans is not None):
            
            self.rTrans = np.insert(self.rTrans, 1, 0, axis = 1)

            self._trans = append(self.rTrans, self.nrTrans)
            self._trans = concatenate((self.rTrans, self.nrTrans), axis = 0)
            self.transFLAG = True
        else:
            self.transFLAG = False

 
        
    cpdef void setTransitions(self, Atom atom):
        
        if self.transFLAG is False:
            self.trans = []
            return
        
        cdef list TRANS = []
        cdef double[:] trans
        cdef int i, k
        cdef double p, E
        cdef Shell shell
        
        for trans in self._trans:
            j, k, p, E = trans[0], int(trans[1]), trans[2], trans[3]
            if k == 0:
                shell = atom[j]
                TRANS.append(Transition._new(shell, shell, p, E, True))
            else:
                TRANS.append(Transition._new(atom[j], atom[k], p, E, False))
            
        self.trans = TRANS
    
    def __repr__(self):
        return str(self.trans)

        
        
        

cdef class Atom:


    
    
    def __init__(self, Z):
        self.Z = Z
        self.vacancies = []
        self.path = directory + "\\EADL\\" + str(Z) + ".txt"
        self.Aw, self.EADL_dict = self.getBookmarkedText()
        
        self.data = {Id:getTable(self.EADL_dict[Id]) for Id in self.EADL_dict}
        
        number_el = self.data[(0, 91, 0, 0, 0, 912)]
        shells = [int(design) for design in number_el[:, 0]]
        
        number_el = number_el[:, 1]
        
        
        binding_energy = self.data[(0, 91, 0, 0, 0, 913)][:, 1]
        KE    = self.data[(0, 91, 0, 0, 0, 914)][:, 1]
        avgR  = self.data[(0, 91, 0, 0, 0, 915)][:, 1]
        #rLW  = self.data[(0, 91, 0, 0, 0, 916)]
        #nrLW = self.data[(0, 91, 0, 0, 0, 917)]
    
        self.SHELLS = []
        cdef int i
        for i in range(len(shells)):
            
            self.SHELLS.append(Shell(shells[i], number_el[i],  binding_energy[i], KE[i], avgR[i], Z,
                                  rTrans  = self.data.get((0, 92, 91, shells[i], 7, 931), None),
                                  nrTrans = self.data.get((0, 92, 91, shells[i], 9, 932), None)
                                  ))
        
        for shell in self.SHELLS:
            shell.setTransitions(self)
            
        self.CS = db.EPDL[Z-1][(7, 73, 0, 0, 0, 0)].getLinLinInterpol()
        
        
    
    def __repr__(self):
        return f"<Atom {self.Z}, Aw = {self.Aw} >"
    
    def __iter__(self):
        yield from self.SHELLS
        
    cdef void _printShells(self):
        cdef Shell shell
        for shell in self.SHELLS:
            print("nVAC:", shell.Nvac)
            print(f"------{shell.i}--------|| ", shell.Nvac*"* | " + int(shell.Nel - shell.Nvac)*"e | ")
            #print("#VACANCIES = ", shell.Nvac)
            #print("#ELECTRONS = ", shell.Nel)
    
    def printShells(self):
        self._printShells()




    cdef void _introduceVacancy(Atom self, Shell shell):
        cdef int i
        cdef Vacancy newVac = Vacancy._new(shell)
        cdef Vacancy oldVac
        for i in range(len(self.vacancies)):
            oldVac = self.vacancies[i]
            if oldVac.current_shell.i < newVac.current_shell.i:
                self.vacancies.insert(i, newVac)
                break
        else:
            self.vacancies.append(newVac)
        
    
    def ionize(self, Shell shell):
        self._introduceVacancy(shell)
    
    def introduceVacancy(self, int i):
        cdef Shell shell
        for shell in self.SHELLS:
            if shell.i == i:
                self.vacancies.append(Vacancy._new(shell))
                
    # cdef void _introduceVacancy(self, int i):
    #     cdef Shell shell
    #     for shell in self.SHELLS:
    #         if shell.i == i:
    #             self.vacancies.append(Vacancy._new(shell))
    
    cpdef printVacancies(self):
        print(self.vacancies)
    
    
    def __getitem__(self, int i):
        cdef Shell shell
        for shell in self.SHELLS:
            if shell.i == i:
                return shell
        return None
        
    
   # def run(self):
   #     return self._run()
    
    cdef list _run(self, Volume current_region, double x, double y, double z):
        self.nSECONDARY = 0
        #cdef dict spectrum = {'el':[], 'ph':[]}
        cdef list secondary = []
        cdef Vacancy activeVac
        cdef list possible_transitions
        cdef Shell shell_i, shell_k, shell_j
        
    
        cdef object probs
        
        cdef list cumul 
        cdef double C, P
        
        cdef int _, i
        cdef Shell j, k
        cdef double E, p2, p1
        cdef double[:, :] possible_transitionsArr
        
        cdef Transition transition, CHOSEN_TRANSITION
        
        while len(self.vacancies) > 0:
            #self.vacancies.sort()
            
            #print("___________________________________________________")
            #self.printShells()

            activeVac = self.vacancies[0]
            
            if activeVac.current_shell.i > 15:
                break
            
            if activeVac.current_shell.trans == []:
                self.vacancies.remove(activeVac)
                continue
                
            
            possible_transitions = []
            #print(activeVac.current_shell.trans)
            for transition in activeVac.current_shell.trans:
                #print(transition)
                if transition.k is False:
                    if transition.j.Nel - transition.j.Nvac > 0:
                        possible_transitions.append(transition)
                        
                elif transition.j == transition.k:
                    if transition.j.Nel - transition.j.Nvac > 1:
                        possible_transitions.append(transition)
                else:
                    if  transition.j.Nel - transition.j.Nvac > 0 \
                    and transition.k.Nel - transition.k.Nvac > 0:
                        possible_transitions.append(transition)

                    
                
            #print(possible_transitions)
            if possible_transitions == []:
                self.vacancies.remove(activeVac)
                continue
            
            if len(possible_transitions) == 1:
                CHOSEN_TRANSITION = possible_transitions[0]
                
            else:
                
                C = 0.
                for transition in possible_transitions:
                    C += transition.p
                
                probs = [transition.p/C for transition in possible_transitions]
                
                cumul = [0.]
                C = 0.
    
                for p in probs:
                    C += p
                    cumul += [C]
                

                #cumul = [sum(probs[0:i]) for i in range(len(probs))]
                for _ in range(100_000):
                    i = search._sortedListDOUBLE(cumul, np.random.rand(), 0, len(cumul)-1)
                    
                    transition = possible_transitions[i-1]
                    
                    #j, k, _, E = possible_transitions[i-1, :]
                    #j, k, E = activeVac.sampleTransition()
                    
                    p2 = (transition.k.Nel - transition.k.Nvac) / transition.k.Nel \
                         if transition.k is not False else 1
                    
                    p1 = (transition.j.Nel - transition.j.Nvac) / transition.j.Nel
    
                    if np.random.rand() < p1*p2:
                        CHOSEN_TRANSITION = transition
                        break
                else:
                    print(possible_transitions)
                    print(activeVac.current_shell.i)
                    print("p1*p2 = ", p1p2)
                    raise RuntimeError("exceeded number of iter")
                
            #if j is None: #or j > 45:
            #    self.vacancies.remove(activeVac)
            #print(CHOSEN_TRANSITION)
            
            
            if CHOSEN_TRANSITION.RADIATIVE is True:
                if CHOSEN_TRANSITION.E > photonCUTOFF:
                    
                    secondary.append(Photon._newISOTROPIC(CHOSEN_TRANSITION.E, 
                                                          x, y, z,
                                                          current_region))
                    self.nSECONDARY += 1
  
                activeVac.move(CHOSEN_TRANSITION.j)
  
            else:
                activeVac.move(CHOSEN_TRANSITION.j)
                self._introduceVacancy(CHOSEN_TRANSITION.k)
                
                if CHOSEN_TRANSITION.E > electronCUTOFF:
                    self.nSECONDARY += 1
                    secondary.append(Electron._newISOTROPIC(CHOSEN_TRANSITION.E*1e6, 
                                                          x, y, z,
                                                          current_region))
  
                    
                #spectrum['el'] += [CHOSEN_TRANSITION.E]
                

        #self.printShells()                
        self.reset()
        return secondary
        
        
        
    cdef void reset(self):
        cdef Shell shell
        self.vacancies = []
        for shell in self.SHELLS:
            shell.Nvac = 0
    
    
    cpdef getBookmarkedText(self):
        cdef str path = self.path

        with open(path, "r") as file:
                text = file.readlines()
                text = [line.strip('\n') for line in text]

                bookmarks = [0]
                
                for n, line in enumerate(text):
                        if line == "                                                                       1":
                                bookmarks += [n + 1]
                                
                #gather all bookmarked text into a dict
                bookmark_ = bookmarks[0:-1]
                _ookmarks = bookmarks[1:]
                
                line0 = text[0]
                Z  = int(line0[0:3])
                Aw = float(line0[13:24])
                
        
                bookmarked_text = {}
                
                for i, j in zip(bookmark_, _ookmarks):
                        line1, line2 = text[i], text[i+1]
                        
                       #on line 1
                        Yi = float(line1[7:9])    #particle identifier
                        Yo = float(line1[10:12])  #secondary particle designator
                        
                        #on line 2
                        C  = float(line2[0:2])    #reaction descriptor
                        I  = float(line2[2:5])    #reaction property
                        S  = float(line2[5:8])    #reaction modifier
                        X1 = float(line2[22:32])  #subshell designator
                        
                        flags = (Yi, C, S, X1, Yo, I)

                        flags = tuple(map(int, flags))
                        bookmarked_text[flags] = text[i+2:j-1]
                        
        return Aw, bookmarked_text
    
    


cdef class Vacancy:

    
    @staticmethod
    def new(Shell current_shell):
        return Vacancy._new(current_shell)
    
    @staticmethod
    cdef Vacancy _new(Shell current_shell):
        self = <Vacancy>Vacancy.__new__(Vacancy)
        
        self.current_shell = current_shell
        #self.current_shell.Nel -= 1
        self.current_shell.Nvac += 1
        return self
        
    
    
    

         
    @property
    def __hash__(Vacancy self):
        return self.current_shell.i
    
    
    cdef void move(Vacancy self, Shell shell):
        #self.current_shell.Nel += 1
        
        cdef Shell current_shell = self.current_shell
        
        current_shell.Nvac -= 1
        #shell.Nel -= 1
        shell.Nvac += 1
        
        self.current_shell = shell

    
    
cdef class Transition:

    
    @staticmethod
    cdef Transition _new(Shell j, Shell k, double p, double E, bint RADIATIVE):
        self = <Transition>Transition.__new__(Transition)
        
        self.j = j
        self.k = k
        self.p = p
        self.E = E
        self.RADIATIVE = RADIATIVE
        return self
    
    def __str__(self):
        return f"<Transition j = {self.j.i}, k = {self.k.i}, p = {self.p}, E = {self.E} >"
  