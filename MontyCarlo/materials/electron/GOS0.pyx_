





from ...tools.interpol1 cimport LogLinInterpolation


cdef double  ELECTRON_REST_MASS      = 0.51099895000e6            
cdef double  _2ELECTRON_REST_MASS    = 2 *ELECTRON_REST_MASS
cdef double _4ELECTRON_REST_MASS_2  = 4*ELECTRON_REST_MASS**2
cdef double SPEED_OF_LIGHT = 2.99792458e10
cdef double    H_BAR                   = 6.5821e-16 
cdef double      MASS_ELECTRON           = 9.1094e-28 
cdef double  ELECTRON_CHARGE         = 4.8032e-10
from numpy import array, logspace
ctypedef double adimensional



#from libcpp.vector cimport vector
#from cython.view cimport array as cvarray

#cdef vector[int] v

from libc.math cimport pi, log
cdef double CONST = 2*pi *ELECTRON_CHARGE**4 / MASS_ELECTRON  *6.242e+11


cdef struct dynS:
    double E
    double X
    double v2
    double beta2
    double delta
    
cdef dynS STATE
cimport cython




cdef class EmptyInterp(LogLinInterpolation):
    def __init__(self):
        pass
    
    cdef double _eval(self, double x):
        return 0


@cython.initializedcheck(False)
@cython.cdivision(True)
cdef class CMolecule:

    
    def __init__(self, object pyMolecule, object cb, object delta):
        cdef list ATOMS = []
        
        STATE.E = 0.
        STATE.X = 0.
        STATE.beta2 = 0.
        STATE.delta = 0.
        STATE.v2 = 0.
        
        
        print("        > creating shells")
        cdef object atom
        for atom in pyMolecule:
            ATOMS.append(CAtom(atom))
            
        self.N = len(ATOMS)
        self.number_density = pyMolecule.N
        
        self.ATOMS = array(ATOMS)
        
        if cb.empty == True:
            self.cb = EmptyShell()
            self.delta = EmptyInterp()
            return
        else:
            self.cb = CShell(cb)
        
        print("        > making density corrections")
        def delta2(double E):
            X = (E/ELECTRON_REST_MASS + 1)**2
            beta2 = (X-1)/X
            return delta(beta2)
        
        print("        > note: KE = logspace(1, 9, 5_000)")
        KE = logspace(1, 9, 5_000)
        dd = array([delta2(E) for E in KE])
        import numpy
        self.delta = LogLinInterpolation(numpy.log10(KE), dd)
        
        
                

        
        
        
    cdef void reset(self):
        self.sigma0, self.sigma1, self.sigma2 = 0, 0, 0
        
    cdef void add(self, double s0, double s1, double s2):
        self.sigma0 += s0
        self.sigma1 += s1 
        self.sigma2 += s2
    
    
    
    @cython.initializedcheck(False)
    @cython.boundscheck(False)
    @cython.wraparound(False)
    cdef void update(self, double E):
        
        
        self.reset()
        
        
        STATE.E = E
        STATE.X = (E/ELECTRON_REST_MASS + 1)**2
        STATE.beta2 = (STATE.X-1)/STATE.X
        STATE.v2 = SPEED_OF_LIGHT**2 * STATE.beta2
        STATE.delta = self.delta._eval(E) #self.delta(beta2)
        #STATE.delta = 0
        
        
        cdef CAtom atom
        cdef int i
        for i in range(self.N):
            atom = self.ATOMS[i]
            atom.update()
            self.add(atom.sigma0, atom.sigma1, atom.sigma2)
        
        self.cb.update()
        self.add(self.cb.sigma0, self.cb.sigma1, self.cb.sigma2)
        
        self.imfp = self.number_density*self.sigma0  
        self.SP = self.number_density*self.sigma1
        self.stragg = self.number_density*self.sigma2
        
        
    def py_update(self, double E):
        self.update(E)
    
    def generate_tables(self, *args):
        Eaxis = logspace(*args)
        sigma0, sigma1, sigma2 = [], [], []
        cdef double E
        for E in Eaxis:
            self.update(E)
            sigma0.append(self.sigma0)
            sigma1.append(self.sigma1)
            sigma2.append(self.sigma2)
        sigma0, sigma1, sigma2 = map(array, (sigma0, sigma1, sigma2) )
        return Eaxis, sigma0, sigma1, sigma2
    

    def cut(self, Wcc):
        cdef CAtom atom
        
        new_atoms = []
        cdef int i
        for i in range(self.N):
            atom = self.ATOMS[i]
            if not atom.cut(Wcc):
                
                new_atoms.append(atom)
        
        if new_atoms == []:
            msg = f"Wcc too small, no shells left in atom. Wcc = {Wcc}"
            print(msg)
            raise RuntimeError(msg)
            
        
        
        self.ATOMS = array(new_atoms)
        self.N = len(self.ATOMS)
        
        print("")
        print("")
        print("SHELLS LEFT IN GOS MODEL:")
        for i in range(self.N):
            atom = self.ATOMS[i]
            print(atom)

        
        if self.cb.Wk < Wcc:
            self.cb = EmptyShell()
            print("NO CB SHELL")
        else:
            print(self.cb)
        


    
@cython.initializedcheck(False)
@cython.cdivision(True)            
cdef class CAtom:

    
    def __init__(self, object pyAtom):
        SHELLS = []
        for shell in pyAtom:
            SHELLS.append(CShell(shell))
        self.SHELLS = array(SHELLS)
        self.N = len(self.SHELLS)
        self.Z = pyAtom.Z
        self.Aw = pyAtom.Aw
        self.I = pyAtom.I
        
    cdef void reset(self):
        self.sigma0, self.sigma1, self.sigma2 = 0, 0, 0
        
    cdef void add(self, double s0, double s1, double s2):
        self.sigma0 += s0
        self.sigma1 += s1 
        self.sigma2 += s2
        
    @cython.initializedcheck(False)
    @cython.boundscheck(False)
    @cython.wraparound(False)
    cdef void update(self):
        cdef CShell shell
        self.reset()
        
        cdef int i
        for i in range(self.N):
            shell = self.SHELLS[i]
            shell.update()
            self.add(shell.sigma0, shell.sigma1, shell.sigma2)
            
    def cut(self, Wcc):
        cdef CShell shell
        
        new_shells = []
        cdef int i
        for i in range(self.N):
            shell = self.SHELLS[i]
            if shell.Wk >= Wcc:
                new_shells.append(shell)
        
        if new_shells == []:
            return True
                
        
        
        self.SHELLS = array(new_shells)
        self.N = len(self.SHELLS)
        return False


    def __repr__(CAtom self):
        
        repres = f"<Atom Z={self.Z}, Aw = {self.Aw} amu, I = {self.I} eV> \n"
        cdef CShell shell
        for shell in self:
            repres += f"    {shell} \n"

        
        
        return repres
    
    def __iter__(self):
        yield from list(self.SHELLS)




cdef class EmptyShell(CShell):
    
    
    def __init__(self):
        self.sigma0 = 0
        self.sigma1 = 0
        self.sigma2 = 0
        
        self.Wk = 0
        self.Uk = 0
        self.fk = 0
        
    
    cdef void update(self):
        pass

@cython.initializedcheck(False)
@cython.cdivision(True)
cdef class CShell:

    
    def __init__(self, object pyShell):
        self.Wk = pyShell.Wk
        self.Uk = pyShell.Uk
        self.fk = pyShell.fk
        
        
        self.distant = Distant._new  (self.fk, self.Wk)
        self.close   = Close._new(self.fk, self.Wk, self.Uk)
        
    cdef void update(self):
        
        #cdef double X = (E/ELECTRON_REST_MASS + 1)**2
        #cdef double beta2 = (X-1)/X                              
        #cdef double v2 = SPEED_OF_LIGHT**2 * beta2
        
        
        cdef double const = CONST / STATE.v2 * self.fk
        #const = const #*6.242e+11*1e+24 #to barn*eV
        
        self.close.update(const)
        self.distant.update(const)
        
        self.sigma0 = self.close.sigma0 + self.distant.sigma0
        self.sigma1 = self.close.sigma1 + self.distant.sigma1
        self.sigma2 = self.close.sigma2 + self.distant.sigma2
        
        
    def __repr__(CShell self):
        return f"<Shell fk = {self.fk}, Uk = {self.Uk} eV, Wk = {self.Wk} eV>"
        
        
@cython.initializedcheck(False)
@cython.cdivision(True)       
cdef class Close:

    
    @staticmethod
    cdef Close _new(double fk, double Wk, double Uk):
        self = <Close>Close.__new__(Close)
        self.fk = fk
        self.Wk = Wk
        self.Uk = Uk
        return self
        
    @cython.cdivision(True)      
    cdef void update(Close self, double const):
        
        
        if STATE.E/2 < self.Wk:
            self.sigma0 = 0
            self.sigma1 = 0
            self.sigma2 = 0
            return
        
        cdef double s0o, s1o, s2o, s0f, s1f, s2f
        s0o, s1o, s2o = Close.J(self.Wk)
        s0f, s1f, s2f = Close.J(STATE.E/2)
        
        
        self.sigma0 = const*(s0f - s0o)
        self.sigma1 = const*(s1f - s1o)
        self.sigma2 = const*(s2f - s2o)
        

    @staticmethod    
    cdef (double, double, double) J(double W):
        cdef double a, J0, J1, J2
        
        a = (STATE.E/(STATE.E + ELECTRON_REST_MASS))**2
        cdef double diff = STATE.E - W
        cdef double logW = log(W)
        cdef double logdiff = log(diff)
    
        J0 = -1/W + 1/diff + (1 - a)/STATE.E * log(diff/W) + a * W/ STATE.E**2
        
        J1 = log(W) + STATE.E /(diff) + (2-a)*log(diff) + a*W**2 / 2 / STATE.E**2
        
        J2 = (2-a)*W + (2*STATE.E**2 - W**2)/(diff) + (3-a)*STATE.E*log(diff) + a*W**3/3/STATE.E**2
    
        return J0, J1, J2
            
        
        
      
cdef struct SIGMA:
    double sigma0, sigma1, sigma2
    
    
@cython.initializedcheck(False)
@cython.cdivision(True)
cdef class Distant:

    
    @staticmethod
    cdef Distant _new(double fk, double Wk):
        self = <Distant>Distant.__new__(Distant)
        self.Wk = Wk
        self.fk = fk

        self.Ldef.sigma0 = 0.; self.Ldef.sigma1 = 0.; self.Ldef.sigma2 = 0.
        self.Tdef.sigma0 = 0.; self.Tdef.sigma1 = 0.; self.Tdef.sigma2 = 0.
        return self
        
    cdef void update(self, double const):
        
        if STATE.E < self.Wk:
            self.L = self.Ldef
            self.T = self.Tdef
            return
        
        cdef double Wk = self.Wk
  
        
        cdef double Q_minus = self.Q_minus(STATE.E)


        cdef double logval = log( Wk  * (Q_minus + _2ELECTRON_REST_MASS)/(  Q_minus*(Wk + _2ELECTRON_REST_MASS)  ))
        cdef double common_mul = const*logval
        
        self.L.sigma0 = common_mul/Wk
        self.L.sigma1 = common_mul
        self.L.sigma2 = common_mul*Wk



        logval = log(STATE.X) - STATE.beta2 - STATE.delta
        common_mul = const*logval
        self.T.sigma0 = common_mul/Wk            #calculation of imfp
        self.T.sigma1 = common_mul               #calculation of stopping power
        self.T.sigma2 = common_mul*Wk            #calculation of energy straggling        
        
        self.sigma0 = self.T.sigma0 + self.L.sigma0
        self.sigma1 = self.T.sigma1 + self.L.sigma1
        self.sigma2 = self.T.sigma2 + self.L.sigma2
                
    cdef double Q_minus(self, double E):
        """eq 3.83"""
        cdef double dE = E - self.Wk
        return ( (self.momentum(E) - self.momentum(dE))**2  + ELECTRON_REST_MASS**2  )**.5 \
               - ELECTRON_REST_MASS 

    cdef double momentum(self, double E):
        return (  E * (E + _2ELECTRON_REST_MASS)  ) ** .5      
